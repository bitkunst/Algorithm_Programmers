# Dynamic Programming (동적 계획법)

-   통상적으로 메모리를 더 사용하여 `시간 복잡도를 개선`할 때 많이 사용된다.
-   구체적으로, 시간 복잡도가 비효율적인 알고리즘이 있을 때 부분 문제의 반복이 발생하는 경우 적용하면 효과적이다.
-   다이나믹 프로그래밍 문제를 해결하기 위해 `점화식`을 찾는 것이 핵심적인 과정이다.

**_일반적으로 부분 문제가 반복되는 경우에 이미 한번 해결한 문제는 별도의 메모리 공간에 기록하는 방식으로 다이나믹 프로그래밍이 사용된다._**

<br>
<br>

## 다이나믹 프로그래밍 사용 조건

-   다이나믹 프로그래밍은 일반적으로 아래의 두 조건을 만족할 때 사용할 수 있다.

1. **최적 부분 구조 (Optimal substructure)**

    - 큰 문제를 유사한 형태의 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아 큰 문제를 해결한다.
    - 큰 문제는 동일한 구조의 작은 문제의 조합으로 해결 가능하다.
    - `점화식` 그 자체로 이해할 수 있다.

2. **반복되는 부분 문제 (Overlapping sub-problem)**

    - 동일한 작은 문제를 반복적으로 해결해야 한다.
    - 해결했던 부분 문제를 또 해결해야 하는 경우가 발생한다.
    - 이미 해결한 문제를 `캐싱` 혹은 `메모이제이션` 하여 해결할 수 있다.

<br>

### 점화식과 최적 부분 구조

-   피보나치 수열 예시 : [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...]
-   `점화식` : 인접한 항으로 현재 값을 결정하는 관계식을 의미한다.
    -   일반적으로 **최적 부분 구조**를 만족한다는 특징이 있다.
-   피보나치 수열의 점화식 :
    -   a(n) = a(n-1) + a(n-2)
    -   a(1) = 1, a(2) = 1

<br>

### 점화식의 구성 요소

-   점화식의 기본적인 구성 요소는 다음과 같다.

1. 초기항
2. 인접한 항과의 관계

-   점화식은 `재귀 함수`로 표현할 수 있다.
-   재귀 함수는 `종료 조건`이 있어야 하는데, 이것이 점화식의 초기항과 같은 역할을 수행한다.

```js
function fibo(x) {
    // 초기항에 대한 내용이 재귀 함수의 종료 조건이 된다.
    if (x === 1 || x === 2) {
        return 1;
    }

    return fibo(x - 1) + fibo(x - 2); // 실질적인 점화식 부분
}

console.log(fibo(4));
```

-   점화식을 `재귀 함수` 코드로 구현할 수 있다.

    1. 점화식의 **_초기항_** 은 **_종료 조건_** 과 같은 역할을 수행한다.
    2. 점화식의 내용은 f(x)의 반환 값에 들어간다.

<br>

### 피보나치 수열 문제

-   피보나치 수열 문제는 다음의 조건을 만족한다.

1. `최적 부분 구조` - 점화식의 형태로 표현 가능
2. `반복되는 부분 문제` - 이미 해결한 문제를 또 해결해야 한다.

-   피보나치 수열의 점화식을 그대로 재귀 함수로 구현하면 어떻게 될까??
    -   **_중복되는 부분 문제가 발생한다._** (이미 구한 값을 불필요하게 반복 계산)
-   다이나믹 프로그래밍은 이 문제를 해결할 수 있도록 해준다.

<br>

### 피보나치 수열 (하향식)

```js
// 한 번 계산된 결과를 메모이제이션(Memoization) 하기 위한 리스트 초기화
const d = new Array(100).fill(0);

function fibo(x) {
    // 피보나치 함수를 재귀 함수로 구현 (탑다운 다이나믹 프로그래밍)
    if (x === 1 || x === 2) {
        // 종료 조건 (1 또는 2일 때 1을 반환)
        return 1;
    }

    // 이미 계산한 적 있는 문제라면 그대로 반환
    if (d[x] !== 0) {
        return d[x];
    }
    // 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2);
    return d[x];
}
```

<br>

### 다이나믹 프로그래밍의 일반 형태

-   다이나믹 프로그래밍(재귀 함수)의 대표적인 코드 형식은 다음과 같다.

```js
function dp() {
    // 1. 종료 조건
    // 2. 이미 해결한 문제라면, 정답을 그대로 반환
    // 3. 점화식에 따라 정답 계산
}
```

<br>

### 다이나믹 프로그래밍 문제 해결 과정

-   다이나믹 프로그래밍 문제 해결 접근 순서는 다음과 같다.

1. 문제 이해하기
2. 점화식 찾아내기 -> 일반적으로 가장 핵심적인 부분이다.
3. 구현 방식 (상향식/하향식) 결정하기
4. 점화식을 실제 코드로 구현하기

<br>

### 다이나믹 프로그래밍 문제 접근 방법

-   다이나믹 프로그래밍 문제는 두 가지 방법으로 접근할 수 있다.

1. `상향식` : 반복문을 이용해 초기 항부터 계산한다.
2. `하향식` : 재귀 함수로 _큰 항을 구하기 위해 작은(이전) 항을 호출_ 하는 방식이다.
    - 이미 구한 함수 값을 담는 테이블을 흔히 **_DP 테이블_** 이라고 한다.
    - **_캐시 테이블_** , **_메모이제이션 기법_**

<br>

### 피보나치 수열 (상향식)

```js
// 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
const d = new Array(100).fill(0);

// 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1;
d[2] = 1;
const n = 99;

// 피보나치 함수 반복문으로 구현 (보텀업 다이나믹 프로그래밍)
for (let i = 3; i <= n; i++) {
    d[i] = d[i - 1] + d[i - 2];
}

console.log(d[n]);
```
